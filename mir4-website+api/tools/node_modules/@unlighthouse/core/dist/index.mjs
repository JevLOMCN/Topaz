import { createHash } from 'node:crypto';
import { join, basename, dirname, resolve, isAbsolute } from 'node:path';
import https from 'node:https';
import { Buffer as Buffer$1 } from 'node:buffer';
import fs, { pathExists, ensureDirSync } from 'fs-extra';
import sanitize from 'sanitize-filename';
import slugify from 'slugify';
import { isRelative, $URL, hasProtocol, withBase, withLeadingSlash, withoutTrailingSlash, withTrailingSlash, normalizeURL, joinURL, withoutLeadingSlash } from 'ufo';
import axios from 'axios';
import fs$1, { existsSync } from 'node:fs';
import { createContext } from 'unctx';
import { createHooks } from 'hookable';
import { loadConfig } from 'unconfig';
import { createDefu, defu } from 'defu';
import objectHash from 'object-hash';
import { resolve as resolve$2, createCommonJS, resolvePath } from 'mlly';
import { $fetch } from 'ofetch';
import { createConsola } from 'consola';
import os, { homedir } from 'node:os';
import { Cluster } from 'puppeteer-cluster';
import { computeExecutablePath, install } from '@puppeteer/browsers';
import { Launcher } from 'chrome-launcher';
import puppeteer from 'puppeteer-core';
import wrapAnsi from 'wrap-ansi';
import chalk from 'chalk';
import boxen from 'boxen';
import { WebSocketServer } from 'ws';
import { createUnrouted, redirect, prefix, post, get as get$1, useQuery, setStatusCode, useParams } from '@unrouted/core';
import launch from 'launch-editor';
import { presetNode, serve } from '@unrouted/preset-node';
import { presetApi } from '@unrouted/preset-api';
import { defineEventHandler } from 'h3';
import { relative, resolve as resolve$1 } from 'pathe';
import { parse } from 'regexparam';
import Sitemapper from 'sitemapper';
import cheerio from 'cheerio';
import { computeMedianRun } from 'lighthouse/lighthouse-core/lib/median-run.js';

const version = "0.8.7";

const AppName = "Unlighthouse";
const ClientPkg = "@unlighthouse/client";
const DefaultColumns = {
  "overview": [
    {
      label: "Screenshot Timeline",
      key: "report.audits.screenshot-thumbnails",
      cols: 6
    }
  ],
  "performance": [
    {
      cols: 2,
      label: "Largest Contentful Paint",
      tooltip: "Largest Contentful Paint marks the time at which the largest text or image is painted. [Learn more](https://web.dev/lighthouse-largest-contentful-paint/)",
      key: "report.audits.largest-contentful-paint",
      sortKey: "numericValue"
    },
    {
      cols: 2,
      label: "Cumulative Layout Shift",
      tooltip: "Cumulative Layout Shift measures the movement of visible elements within the viewport.",
      sortKey: "numericValue",
      key: "report.audits.cumulative-layout-shift"
    },
    {
      cols: 1,
      label: "FID",
      tooltip: "The maximum potential First Input Delay that your users could experience is the duration of the longest task. [Learn more](https://web.dev/lighthouse-max-potential-fid/).",
      sortKey: "numericValue",
      key: "report.audits.max-potential-fid"
    },
    {
      cols: 1,
      label: "Blocking",
      tooltip: "Sum of all time periods between FCP and Time to Interactive, when task length exceeded 50ms, expressed in milliseconds. [Learn more](https://web.dev/lighthouse-total-blocking-time/).",
      sortKey: "numericValue",
      key: "report.audits.total-blocking-time"
    },
    {
      cols: 2,
      label: "Network Requests",
      sortKey: "length:details.items",
      tooltip: "The requests made during the page render. The size unit is the transfer size of the resources, typically gziped.",
      key: "report.audits.network-requests"
    }
  ],
  // accessibility
  "accessibility": [
    {
      cols: 3,
      label: "Color Contrast",
      tooltip: "Background and foreground colors do not have a sufficient contrast ratio.",
      sortKey: "length:details.items",
      key: "report.audits.color-contrast"
    },
    {
      cols: 1,
      label: "Headings",
      tooltip: "Heading elements appear in a sequentially-descending order",
      sortKey: "length:details.items",
      key: "report.audits.heading-order"
    },
    {
      cols: 1,
      label: "ARIA",
      tooltip: "An aggregate of all ARIA audits.",
      sortKey: "displayValue",
      sortable: true,
      key: "report.computed.ariaIssues"
    },
    {
      cols: 1,
      label: "Labels",
      tooltip: "Form elements have associated labels",
      sortKey: "length:details.items",
      key: "report.audits.label"
    },
    {
      cols: 1,
      label: "Image Alts",
      tooltip: "Image elements have [alt] attributes",
      sortKey: "length:details.items",
      key: "report.audits.image-alt"
    },
    {
      cols: 1,
      label: "Link Names",
      tooltip: "Links do not have a discernible name",
      sortKey: "length:details.items",
      key: "report.audits.link-name"
    }
  ],
  // best practices
  "best-practices": [
    {
      cols: 2,
      label: "Errors",
      tooltip: "No browser errors logged to the console",
      sortKey: "length:details.items",
      key: "report.audits.errors-in-console"
    },
    {
      cols: 2,
      label: "Inspector Issues",
      tooltip: "No issues in the `Issues` panel in Chrome Devtools",
      sortKey: "length:details.items",
      key: "report.audits.inspector-issues"
    },
    {
      cols: 2,
      label: "Images Responsive",
      tooltip: "Serves images with appropriate resolution",
      sortKey: "length:details.items",
      key: "report.audits.image-size-responsive"
    },
    {
      cols: 2,
      label: "Image Aspect Ratio",
      tooltip: "Displays images with correct aspect ratio",
      sortKey: "length:details.items",
      key: "report.audits.image-aspect-ratio"
    }
  ],
  // seo
  "seo": [
    {
      cols: 1,
      label: "Indexable",
      tooltip: "Page isn\u2019t blocked from indexing",
      key: "report.audits.is-crawlable"
    },
    { cols: 1, label: "Internal link", sortable: true, key: "seo.internalLinks" },
    { cols: 1, label: "External link", sortable: true, key: "seo.externalLinks" },
    {
      cols: 1,
      label: "Tap Targets",
      tooltip: "Tap targets are sized appropriately",
      key: "report.audits.tap-targets"
    },
    {
      cols: 2,
      label: "Description",
      key: "seo.description"
    },
    {
      cols: 2,
      label: "Share Image",
      key: "seo.og.image"
    }
  ],
  "pwa": [
    {
      cols: 2,
      label: "Manifest",
      key: "report.audits.installable-manifest"
    },
    { cols: 1, label: "Service Worker", key: "report.audits.service-worker" },
    { cols: 1, label: "Splash Screen", key: "report.audits.splash-screen" },
    {
      cols: 2,
      label: "Viewport",
      key: "report.audits.viewport"
    },
    {
      cols: 2,
      label: "Content Width",
      key: "report.audits.content-width"
    }
  ]
};
const defaultConfig = {
  routerPrefix: "/",
  apiPrefix: "/api",
  cache: true,
  client: {
    /**
     * By default try and group routes by the definition name, if no definition is found this will resolve
     * to the route.path.
     */
    groupRoutesKey: "route.definition.name",
    columns: DefaultColumns
  },
  scanner: {
    customSampling: {},
    ignoreI18nPages: true,
    maxRoutes: 200,
    skipJavascript: true,
    samples: 1,
    throttle: false,
    crawler: true,
    dynamicSampling: 5,
    sitemap: true,
    robotsTxt: true,
    device: "mobile"
  },
  // @ts-expect-error provided by server package, may not be provided in CI mode
  server: {
    port: 5678,
    showURL: false,
    open: true
  },
  discovery: {
    supportedExtensions: ["vue", "md"],
    pagesDir: "pages"
  },
  root: process.cwd(),
  outputPath: ".unlighthouse",
  debug: false,
  puppeteerOptions: {},
  puppeteerClusterOptions: {
    monitor: true,
    workerCreationDelay: 500,
    retryLimit: 3,
    timeout: 5 * 60 * 1e3,
    // wait for up to 5 minutes.
    // max concurrency is the amount of cpu cores we have
    maxConcurrency: os.cpus().length,
    skipDuplicateUrls: false,
    retryDelay: 2e3,
    // Important, when using Lighthouse we want browser isolation.
    concurrency: Cluster.CONCURRENCY_BROWSER
  },
  lighthouseOptions: {
    onlyCategories: ["performance", "accessibility", "best-practices", "seo"]
  }
};

const loggerCtx = createContext();
function createLogger(debug = false) {
  const logger = createConsola().withTag(AppName);
  if (debug) {
    logger.level = 4;
  }
  loggerCtx.set(logger);
  return logger;
}
const useLogger = () => {
  let logger = loggerCtx.use();
  if (!logger)
    logger = createLogger();
  return logger;
};

function createScanMeta() {
  const { worker } = useUnlighthouse();
  const data = worker.reports().filter((r) => r.tasks.inspectHtmlTask === "completed");
  const reportsWithScore = data.filter((r) => r.report?.score);
  const score = reportsWithScore.map((r) => r.report.score).reduce((s, a) => s + a, 0) / reportsWithScore.length || 0;
  return {
    favicon: data?.[0]?.seo?.favicon,
    monitor: worker.monitor(),
    routes: data.length || 0,
    score
  };
}

async function createApi(h3) {
  const logger = useLogger();
  const { ws, resolvedConfig, runtimeSettings, hooks } = useUnlighthouse();
  const useReport = () => {
    const { worker } = useUnlighthouse();
    const { id } = useParams();
    return worker.findReport(id);
  };
  const { app, setup } = await createUnrouted({
    name: "unlighthouse-api",
    debug: resolvedConfig.debug,
    prefix: resolvedConfig.routerPrefix,
    app: h3,
    hooks: {
      // @ts-expect-error untyped
      "serve:before-route": () => {
        return hooks.callHook("visited-client");
      }
    },
    presets: [
      presetApi(),
      presetNode({
        generateTypes: false
      })
    ]
  });
  await setup(() => {
    redirect("/__lighthouse/", resolvedConfig.routerPrefix);
    prefix("/api", () => {
      prefix("/reports", () => {
        post("/rescan", () => {
          const { worker } = useUnlighthouse();
          const reports = [...worker.routeReports.values()];
          logger.info(`Doing site rescan, clearing ${reports.length} reports.`);
          worker.routeReports.clear();
          reports.forEach((route) => {
            const dir = route.artifactPath;
            if (fs.existsSync(dir))
              fs.rmSync(dir, { recursive: true });
          });
          worker.queueRoutes(reports.map((report) => report.route));
          return true;
        });
        post("/:id/rescan", () => {
          const report = useReport();
          const { worker } = useUnlighthouse();
          if (report)
            worker.requeueReport(report);
        });
      });
      get$1("__launch", () => {
        const { file } = useQuery();
        if (!file) {
          setStatusCode(400);
          return false;
        }
        const path = file.replace(resolvedConfig.root, "");
        const resolved = join(resolvedConfig.root, path);
        logger.info(`Launching file in editor: \`${path}\``);
        launch(resolved);
      });
      get$1("ws", defineEventHandler((event) => ws.serve(event.req)));
      get$1("reports", () => {
        const { worker } = useUnlighthouse();
        return worker.reports().filter((r) => r.tasks.inspectHtmlTask === "completed");
      });
      get$1("scan-meta", () => createScanMeta());
    });
    serve("/", runtimeSettings.generatedClientPath);
  });
  return app;
}

const createMockRouter = (routeDefinitions) => {
  const logger = useLogger();
  const patterns = routeDefinitions.map((r) => {
    try {
      return {
        routeDefinition: r,
        matcher: parse(r.path)
      };
    } catch (e) {
      logger.debug("Failed to parse path", r.path, e);
    }
    return false;
  }).filter((r) => r !== false);
  return {
    match(path) {
      const matched = patterns.filter((p) => p && p.matcher.pattern.test(path));
      if (matched.length > 0 && matched[0])
        return matched[0].routeDefinition;
      return false;
    }
  };
};

function isScanOrigin(url) {
  if (isRelative(url) || url.startsWith("/") && !url.startsWith("//"))
    return true;
  const { runtimeSettings } = useUnlighthouse();
  const $url = new $URL(url);
  if ($url.hostname === runtimeSettings.siteUrl.hostname)
    return true;
  return $url.hostname.endsWith(`.${runtimeSettings.siteUrl.hostname}`);
}
function normaliseRoute(url) {
  const { runtimeSettings, provider, resolvedConfig } = useUnlighthouse();
  if (!hasProtocol(url)) {
    url = withBase(url, runtimeSettings.siteUrl.origin);
  }
  const $url = new $URL(url);
  const path = withLeadingSlash($url.pathname);
  let normalised = {
    id: hashPathName(path),
    url,
    $url,
    path
  };
  for (const matcher in resolvedConfig.scanner.customSampling) {
    if (!new RegExp(matcher).test(path))
      continue;
    const definition = resolvedConfig.scanner.customSampling[matcher];
    normalised = {
      ...normalised,
      definition: {
        ...definition,
        path,
        componentBaseName: basename(definition.component || "")
      }
    };
    break;
  }
  if (!normalised.definition && provider.mockRouter && typeof provider.mockRouter !== "function") {
    const definition = provider.mockRouter.match(path);
    if (definition) {
      if (definition.file && !definition.component)
        definition.component = definition.file;
      normalised = {
        ...normalised,
        definition: {
          ...definition,
          componentBaseName: basename(definition.component || "")
        }
      };
    }
  }
  if (!normalised.definition) {
    const parts = trimSlashes(path).split("/");
    let name;
    if (path === "/") {
      name = "index";
    } else if (parts.length > 1) {
      name = parts.map((val, i) => {
        if (i >= parts.length - 1)
          return "slug";
        return val;
      }).join("-");
    } else {
      name = trimSlashes(path);
    }
    normalised = {
      ...normalised,
      definition: {
        name,
        path
      }
    };
  }
  if (normalised?.definition?.name === "index")
    normalised.definition.name = "_index";
  return normalised;
}

function createBroadcastingEvents() {
  const { hooks, ws } = useUnlighthouse();
  if (!ws)
    return;
  hooks.hook("task-started", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
  hooks.hook("task-complete", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
  hooks.hook("task-added", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
}
class WS {
  constructor() {
    this.wss = new WebSocketServer({ noServer: true });
  }
  serve(req) {
    this.handleUpgrade(req, req.socket);
  }
  handleUpgrade(request, socket) {
    return this.wss.handleUpgrade(request, socket, Buffer$1.alloc(0), (client) => {
      this.wss.emit("connection", client, request);
    });
  }
  /**
     * Publish event and data to all connected clients
     * @param {object} data
     */
  broadcast(data) {
    const jsonData = JSON.stringify(data);
    for (const client of this.wss.clients) {
      try {
        client.send(jsonData);
      } catch (err) {
      }
    }
  }
}

async function launchPuppeteerCluster() {
  const { resolvedConfig } = useUnlighthouse();
  const cluster = await Cluster.launch({
    puppeteerOptions: resolvedConfig.puppeteerOptions,
    ...resolvedConfig.puppeteerClusterOptions
  });
  cluster.display = {
    log() {
    },
    resetCursor() {
    }
  };
  return cluster;
}

const extractHtmlPayload = async (page, route) => {
  const { worker, resolvedConfig, hooks } = useUnlighthouse();
  if (resolvedConfig.scanner.skipJavascript) {
    const { valid, response, redirected, redirectUrl } = await fetchUrlRaw(route, resolvedConfig);
    if (!valid || !response)
      return { success: false, message: `Invalid response from URL ${route} code: ${response?.status || "404"}.` };
    if (response.headers["content-type"] && !response.headers["content-type"].includes("text/html"))
      return { success: false, message: `Non-HTML Content-Type header: ${response.headers["content-type"]}.` };
    return {
      success: true,
      redirected: redirected ? redirectUrl : false,
      payload: response.data
    };
  }
  try {
    await page.setCacheEnabled(false);
    await page.setRequestInterception(true);
    page.on("request", (request) => {
      if (["image", "stylesheet", "font", "other"].includes(request.resourceType()))
        request.abort();
      else
        request.continue();
    });
    await hooks.callHook("puppeteer:before-goto", page);
    const pageVisit = await page.goto(route, { waitUntil: resolvedConfig.scanner.skipJavascript ? "domcontentloaded" : "networkidle0" });
    const { "content-type": contentType, location } = pageVisit.headers();
    const statusCode = pageVisit.status();
    if ((statusCode === 301 || statusCode === 302) && location) {
      worker.queueRoute(normaliseRoute(location));
      return { success: false, message: `Redirect, queued the new URL: ${location}.` };
    }
    if (statusCode < 200 || statusCode >= 300)
      return { success: false, message: `Invalid status code: ${statusCode}.` };
    if (contentType && !contentType.includes("text/html"))
      return { success: false, message: `Invalid content-type header: ${contentType}.` };
    const payload = await (resolvedConfig.scanner.skipJavascript ? pageVisit.text() : page.evaluate(() => document.querySelector("*")?.outerHTML));
    return {
      success: true,
      payload
    };
  } catch (e) {
    return { success: false, message: `Exception thrown when visiting route: ${e}.` };
  }
};
function processSeoMeta($) {
  return {
    alternativeLangDefault: $('link[hreflang="x-default"]').attr("href"),
    favicon: $('link[rel~="icon"]').attr("href") || "/favicon.ico",
    title: $("meta[name='title'], head > title").text(),
    description: $("meta[name='description']").attr("content"),
    og: {
      image: $("meta[property='og:image'], meta[name='og:image']").attr("content"),
      description: $("meta[property='og:description'], meta[name='og:description']").attr("content"),
      title: $("meta[property='og:title'], meta[name='og:title']").attr("content")
    }
  };
}
const inspectHtmlTask = async (props) => {
  const { resolvedConfig, hooks, runtimeSettings } = useUnlighthouse();
  const { page, data: routeReport } = props;
  const logger = useLogger();
  let html;
  const start = /* @__PURE__ */ new Date();
  const htmlPayloadPath = join(routeReport.artifactPath, ReportArtifacts.html);
  let cached = false;
  if (resolvedConfig.cache && fs.existsSync(htmlPayloadPath)) {
    html = fs.readFileSync(htmlPayloadPath, { encoding: "utf-8" });
    logger.debug(`Running \`inspectHtmlTask\` for \`${routeReport.route.path}\` using cache.`);
    cached = true;
  } else {
    const response = await extractHtmlPayload(page, routeReport.route.url);
    logger.debug(`HTML extract of \`${routeReport.route.url}\` response ${response.success ? "succeeded" : "failed"}.`);
    if (!response.success || !response.payload) {
      routeReport.tasks.inspectHtmlTask = "ignore";
      logger.info(`Skipping ${routeReport.route.path}. ${response.message}`);
      return routeReport;
    }
    if (response.redirected) {
      const siteHost = runtimeSettings.siteUrl.host.split(":")[0];
      const redirectHost = new $URL(response.redirected).host.split(":")[0];
      if (siteHost !== redirectHost && !redirectHost.endsWith(`.${siteHost}`)) {
        routeReport.tasks.inspectHtmlTask = "ignore";
        logger.warn(`Redirected URL goes to a different domain, ignoring. \`${response.redirected}.`);
        return routeReport;
      }
      if (withoutTrailingSlash(response.redirected) !== runtimeSettings.siteUrl.href)
        logger.info("Redirected url detected, this may cause issues in the final report.", response.redirected);
    }
    html = response.payload;
  }
  const $ = cheerio.load(html);
  routeReport.seo = processSeoMeta($);
  if (resolvedConfig.scanner.ignoreI18nPages && routeReport.seo.alternativeLangDefault && withoutTrailingSlash(routeReport.route.url) !== withoutTrailingSlash(routeReport.seo.alternativeLangDefault)) {
    routeReport.tasks.inspectHtmlTask = "ignore";
    logger.debug(`Page has an alternative lang, ignoring \`${routeReport.route.path}\`: ${routeReport.seo.alternativeLangDefault}`);
    const unlighthouse = useUnlighthouse();
    unlighthouse.worker.queueRoute(normaliseRoute(routeReport.seo.alternativeLangDefault));
    return routeReport;
  }
  const internalLinks = [];
  const externalLinks = [];
  $("a").each(function() {
    const href = $(this).attr("href");
    if (!href || href.includes("javascript:") || href.includes("mailto:") || href === "#")
      return;
    if (!href.endsWith("/")) {
      const parts = href.split(".");
      if (parts.length > 1) {
        const extension = trimSlashes(parts[parts.length - 1]).replace(".", "");
        if (extension !== "html")
          return;
      }
    }
    if (href.startsWith("/") && !href.startsWith("//") || href.includes(resolvedConfig.site))
      internalLinks.push(href);
    else
      externalLinks.push(href);
  });
  await hooks.callHook("discovered-internal-links", routeReport.route.path, internalLinks);
  routeReport.seo.internalLinks = internalLinks.length;
  routeReport.seo.externalLinks = externalLinks.length;
  const end = /* @__PURE__ */ new Date();
  const ms = Math.round(end.getTime() - start.getTime());
  const seconds = (ms / 1e3).toFixed(1);
  if (!cached)
    logger.success(`Completed \`inspectHtmlTask\` for \`${routeReport.route.path}\`. ${chalk.gray(`(${formatBytes(html.length)} took ${seconds}s)`)}`);
  if (resolvedConfig.cache)
    fs.writeFileSync(htmlPayloadPath, html);
  return routeReport;
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

const freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

const root$1 = root;

/** Built-in value references. */
var Symbol = root$1.Symbol;

const Symbol$1 = Symbol;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$d.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$d.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$c.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag$1);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

const isArray$1 = isArray;

/** Used as references for various `Number` constants. */
var INFINITY$3 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

const coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$b = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$9).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root$1, 'WeakMap');

const WeakMap$1 = WeakMap;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

const defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

const baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString$1);

const setToString$1 = setToString;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$8.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

const isArguments$1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer = moduleExports$1 ? root$1.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

const isBuffer$1 = isBuffer;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal$1.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

const nodeUtil$1 = nodeUtil;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

const isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$6.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

const nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

const nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root$1, 'Map');

const Map$2 = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$2 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

const stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments$1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString$1(overRest(func, undefined, flatten), func + '');
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

const getSymbols$1 = getSymbols;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root$1, 'DataView');

const DataView$1 = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root$1, 'Promise');

const Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root$1, 'Set');

const Set$2 = Set$1;

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag$1 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
    (Map$2 && getTag(new Map$2) != mapTag$1) ||
    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
    (Set$2 && getTag(new Set$2) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

const getTag$1 = getTag;

/** Built-in value references. */
var Uint8Array = root$1.Uint8Array;

const Uint8Array$1 = Uint8Array;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray$1(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray$1(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

const baseFor$1 = baseFor;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

const baseEach$1 = baseEach;

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$1(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach$1(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

const groupBy$1 = groupBy;

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray$1(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

const pick$1 = pick;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeRandom = Math.random;

/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */
function baseRandom(lower, upper) {
  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}

/**
 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
 *
 * @private
 * @param {Array} array The array to shuffle.
 * @param {number} [size=array.length] The size of `array`.
 * @returns {Array} Returns `array`.
 */
function shuffleSelf(array, size) {
  var index = -1,
      length = array.length,
      lastIndex = length - 1;

  size = size === undefined ? length : size;
  while (++index < size) {
    var rand = baseRandom(index, lastIndex),
        value = array[rand];

    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size;
  return array;
}

/**
 * A specialized version of `_.sampleSize` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */
function arraySampleSize(array, n) {
  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
}

/**
 * The base implementation of `_.sampleSize` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @param {number} n The number of elements to sample.
 * @returns {Array} Returns the random elements.
 */
function baseSampleSize(collection, n) {
  var array = values(collection);
  return shuffleSelf(array, baseClamp(n, 0, array.length));
}

/**
 * Gets `n` random elements at unique keys from `collection` up to the
 * size of `collection`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @param {number} [n=1] The number of elements to sample.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the random elements.
 * @example
 *
 * _.sampleSize([1, 2, 3], 2);
 * // => [3, 1]
 *
 * _.sampleSize([1, 2, 3], 4);
 * // => [2, 3, 1]
 */
function sampleSize(collection, n, guard) {
  if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
    n = 1;
  } else {
    n = toInteger(n);
  }
  var func = isArray$1(collection) ? arraySampleSize : baseSampleSize;
  return func(collection, n);
}

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

const sortBy$1 = sortBy;

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 *
 * // The `_.property` iteratee shorthand.
 * _.sumBy(objects, 'n');
 * // => 20
 */
function sumBy(array, iteratee) {
  return (array && array.length)
    ? baseSum(array, baseIteratee(iteratee))
    : 0;
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$2 && (1 / setToArray(new Set$2([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set$2(values);
};

const createSet$1 = createSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet$1(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee)) : [];
}

function normaliseLighthouseResult(route, result) {
  const { resolvedConfig, runtimeSettings } = useUnlighthouse();
  const measuredCategories = Object.values(result.categories).filter((c) => typeof c.score !== "undefined");
  const columnFields = Object.values(resolvedConfig.client.columns).flat().filter((c) => !!c.key).map((c) => c.key?.replace("report.", ""));
  const imageIssues = [
    result.audits["unsized-images"]?.details?.items || [],
    result.audits["preload-lcp-image"]?.details?.items || [],
    result.audits["offscreen-images"]?.details?.items || [],
    result.audits["modern-image-formats"]?.details?.items || [],
    result.audits["uses-optimized-images"]?.details?.items || [],
    result.audits["efficient-animated-content"]?.details?.items || [],
    result.audits["uses-responsive-images"]?.details?.items || []
  ].flat();
  const ariaIssues = Object.values(result.audits).filter((a) => a && a.id.startsWith("aria-") && a.details?.items?.length > 0).map((a) => a.details?.items).flat();
  if (result.audits["screenshot-thumbnails"]?.details?.items) {
    for (const k in result.audits["screenshot-thumbnails"].details.items)
      result.audits["screenshot-thumbnails"].details.items[k].data = relative(runtimeSettings.generatedClientPath, join(route.artifactPath, ReportArtifacts.screenshotThumbnailsDir, `${k}.jpeg`));
  }
  return {
    // @ts-expect-error type override
    categories: map(result.categories, (c, k) => {
      return {
        key: k,
        id: k,
        ...pick$1(c, ["title", "score"])
      };
    }),
    ...pick$1(result, [
      "audits.redirects",
      // core web vitals
      "audits.layout-shift-elements",
      "audits.largest-contentful-paint-element",
      "audits.largest-contentful-paint",
      "audits.cumulative-layout-shift",
      "audits.first-contentful-paint",
      "audits.total-blocking-time",
      "audits.max-potential-fid",
      "audits.interactive",
      ...columnFields
    ]),
    computed: {
      imageIssues: {
        details: {
          items: imageIssues
        },
        displayValue: imageIssues.length,
        score: imageIssues.length > 0 ? 0 : 1
      },
      ariaIssues: {
        details: {
          items: ariaIssues
        },
        displayValue: ariaIssues.length,
        score: ariaIssues.length > 0 ? 0 : 1
      }
    },
    score: Math.round(sumBy(measuredCategories, "score") / measuredCategories.length * 100) / 100
  };
}
const runLighthouseTask = async (props) => {
  const logger = useLogger();
  const { resolvedConfig, runtimeSettings, worker, hooks } = useUnlighthouse();
  const { page, data: routeReport } = props;
  const reportJsonPath = join(routeReport.artifactPath, ReportArtifacts.reportJson);
  if (resolvedConfig.cache && fs.existsSync(reportJsonPath)) {
    const report2 = fs.readJsonSync(reportJsonPath, { encoding: "utf-8" });
    routeReport.report = normaliseLighthouseResult(routeReport, report2);
    return routeReport;
  }
  const browser = page.browser();
  const port = new URL(browser.wsEndpoint()).port;
  await page.setBypassCSP(true);
  if (resolvedConfig.auth)
    await page.authenticate(resolvedConfig.auth);
  if (resolvedConfig.cookies)
    await page.setCookie(...resolvedConfig.cookies);
  if (resolvedConfig.extraHeaders)
    await page.setExtraHTTPHeaders(resolvedConfig.extraHeaders);
  browser.on("targetchanged", async (target) => {
    const page2 = await target.page();
    if (page2) {
      if (resolvedConfig.cookies)
        await page2.setCookie(...resolvedConfig.cookies);
      if (resolvedConfig.extraHeaders)
        await page2.setExtraHTTPHeaders(resolvedConfig.extraHeaders);
      await hooks.callHook("puppeteer:before-goto", page2);
    }
  });
  const args = [
    `--cache=${JSON.stringify(resolvedConfig.cache)}`,
    `--routeReport=${JSON.stringify(pick$1(routeReport, ["route.url", "artifactPath"]))}`,
    `--lighthouseOptions=${JSON.stringify(resolvedConfig.lighthouseOptions)}`,
    `--port=${port}`
  ];
  const samples = [];
  for (let i = 0; i < resolvedConfig.scanner.samples; i++) {
    try {
      const worker2 = (await import('execa')).execa(
        // handles stubbing
        runtimeSettings.lighthouseProcessPath.endsWith(".ts") ? "jiti" : "node",
        [runtimeSettings.lighthouseProcessPath, ...args],
        {
          timeout: 6 * 60 * 1e3
        }
      );
      worker2.stdout.pipe(process.stdout);
      worker2.stderr.pipe(process.stderr);
      const res = await worker2;
      if (res)
        samples.push(fs.readJsonSync(reportJsonPath));
    } catch (e) {
      logger.error("Failed to run lighthouse for route", e);
      return routeReport;
    }
  }
  let report = samples[0];
  if (samples.length > 1) {
    try {
      report = computeMedianRun(samples);
    } catch (e) {
      logger.warn("Error when computing median score, possibly audit failed.", e);
    }
  }
  if (!report) {
    logger.error(`Task \`runLighthouseTask\` has failed to run for path "${routeReport.route.path}".`);
    routeReport.tasks.runLighthouseTask = "failed";
  }
  if (report.audits?.["final-screenshot"]?.details?.data)
    await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.screenshot), base64ToBuffer(report.audits["final-screenshot"].details.data));
  if (report.audits?.["full-page-screenshot"]?.details?.screenshot?.data)
    await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.fullScreenScreenshot), base64ToBuffer(report.audits["full-page-screenshot"].details.screenshot.data));
  const screenshotThumbnails = report.audits?.["screenshot-thumbnails"]?.details;
  await fs.mkdir(join(routeReport.artifactPath, ReportArtifacts.screenshotThumbnailsDir), { recursive: true });
  if (screenshotThumbnails?.items && screenshotThumbnails.type === "filmstrip") {
    for (const key in screenshotThumbnails.items) {
      const thumbnail = screenshotThumbnails.items[key];
      await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.screenshotThumbnailsDir, `${key}.jpeg`), base64ToBuffer(thumbnail.data));
    }
  }
  routeReport.report = normaliseLighthouseResult(routeReport, report);
  logger.success(`Completed \`runLighthouseTask\` for \`${routeReport.route.path}\`. ${chalk.gray(`(Score: ${routeReport.report.score}${resolvedConfig.scanner.samples > 0 ? ` Samples: ${resolvedConfig.scanner.samples}` : ""} ${worker.monitor().donePercStr}% complete)`)}`);
  return routeReport;
};

let warnedMaxRoutesExceeded = false;
async function createUnlighthouseWorker(tasks) {
  const { hooks, resolvedConfig } = useUnlighthouse();
  const logger = useLogger();
  const cluster = await launchPuppeteerCluster();
  const routeReports = /* @__PURE__ */ new Map();
  const ignoredRoutes = /* @__PURE__ */ new Set();
  const monitor = () => {
    const now = Date.now();
    const timeDiff = now - cluster.startTime;
    const doneTargets = cluster.allTargetCount - cluster.jobQueue.size() - cluster.workersBusy.length;
    const donePercentage = cluster.allTargetCount === 0 ? 1 : doneTargets / cluster.allTargetCount;
    const donePercStr = (100 * donePercentage).toFixed(0);
    const errorPerc = doneTargets === 0 ? "0.00" : (100 * cluster.errorCount / doneTargets).toFixed(2);
    const timeRunning = timeDiff;
    let timeRemainingMillis = -1;
    if (donePercentage !== 0)
      timeRemainingMillis = Math.round(timeDiff / donePercentage - timeDiff);
    const timeRemaining = timeRemainingMillis;
    const cpuUsage = `${cluster.systemMonitor.getCpuUsage().toFixed(1)}%`;
    const memoryUsage = `${cluster.systemMonitor.getMemoryUsage().toFixed(1)}%`;
    const pagesPerSecond = doneTargets === 0 ? "0" : (doneTargets * 1e3 / timeDiff).toFixed(2);
    return {
      status: cluster.allTargetCount === doneTargets ? "completed" : "working",
      timeRunning,
      doneTargets,
      allTargets: cluster.allTargetCount,
      donePercStr,
      errorPerc,
      timeRemaining,
      pagesPerSecond,
      cpuUsage,
      memoryUsage,
      workers: cluster.workers.length + cluster.workersStarting
    };
  };
  const exceededMaxRoutes = () => {
    return resolvedConfig.scanner.maxRoutes !== false && routeReports.size >= resolvedConfig.scanner.maxRoutes;
  };
  const queueRoute = (route) => {
    const { id, path } = route;
    if (exceededMaxRoutes()) {
      if (!warnedMaxRoutesExceeded) {
        logger.warn(`You have reached the \`scanner.maxRoutes\` limit of ${resolvedConfig.scanner.maxRoutes}. No further routes will be queued, consider raising this limit.`);
        warnedMaxRoutesExceeded = true;
        return;
      }
      return;
    }
    if (routeReports.has(id))
      return;
    if (ignoredRoutes.has(id))
      return;
    if (resolvedConfig.scanner.include) {
      if (resolvedConfig.scanner.include.filter((rule) => asRegExp(rule).test(path)).length === 0)
        return;
    }
    if (resolvedConfig.scanner.exclude) {
      if (resolvedConfig.scanner.exclude.filter((rule) => asRegExp(rule).test(path)).length > 0)
        return;
    }
    if (resolvedConfig.scanner.dynamicSampling > 0) {
      const routeGroup = get(route, resolvedConfig.client.groupRoutesKey.replace("route.", ""));
      const routesInGroup = [...routeReports.values()].filter(
        (r) => get(r, resolvedConfig.client.groupRoutesKey) === routeGroup
      ).length;
      if (routesInGroup >= resolvedConfig.scanner.dynamicSampling) {
        return;
      }
    }
    const routeReport = createTaskReportFromRoute(route);
    logger.debug(`Route has been queued. Path: \`${path}\` Name: ${routeReport.route.definition?.name}.`);
    routeReports.set(id, routeReport);
    hooks.callHook("task-added", path, routeReport);
    const runTaskIndex = (idx = 0) => {
      const taskName = Object.keys(tasks)?.[idx];
      if (!taskName) {
        if (monitor().status === "completed")
          hooks.callHook("worker-finished");
        return;
      }
      const task = Object.values(tasks)[idx];
      routeReport.tasks[taskName] = "waiting";
      cluster.execute(routeReport, (arg) => {
        routeReport.tasks[taskName] = "in-progress";
        hooks.callHook("task-started", path, routeReport);
        return task(arg);
      }).then((response) => {
        if (response.tasks[taskName] === "ignore") {
          routeReports.delete(id);
          ignoredRoutes.add(id);
          logger.debug(`Ignoring route \`${routeReport.route.path}\`.`);
          return;
        }
        if (response.tasks[taskName] === "failed")
          return;
        response.tasks[taskName] = "completed";
        routeReports.set(id, response);
        hooks.callHook("task-complete", path, response, taskName);
        runTaskIndex(idx + 1);
      });
    };
    runTaskIndex();
  };
  const queueRoutes = (routes) => {
    routes = uniqBy(routes, "path");
    const sortedRoutes = sortBy$1(
      routes,
      // we're sort all routes by their route name if provided, otherwise use the path
      (r) => {
        if (resolvedConfig.discovery && r.definition)
          return get(r, resolvedConfig.client.groupRoutesKey.replace("route.", ""));
        return r.path;
      }
    );
    sortedRoutes.forEach((route) => queueRoute(route));
  };
  const requeueReport = (report) => {
    logger.info(`Submitting \`${report.route.path}\` for a re-queue.`);
    Object.values(ReportArtifacts).forEach((artifact) => {
      fs$1.rmSync(join(report.artifactPath, artifact), { force: true, recursive: true });
    });
    routeReports.delete(report.reportId);
    setTimeout(() => {
      queueRoute(report.route);
    }, 3500);
  };
  const hasStarted = () => cluster.workers.length || cluster.workersStarting;
  const reports = () => [...routeReports.values()];
  const invalidateFile = (file) => {
    if (file.startsWith(resolvedConfig.outputPath))
      return false;
    const matched = reports().filter((r) => r.route.definition.component === file || r.route.definition.component?.endsWith(file));
    if (matched.length) {
      logger.info(`Invalidating file ${file}, matched ${matched.length} routes.`);
      matched.forEach((r) => requeueReport(r));
      return true;
    }
    return false;
  };
  const findReport = (id) => reports().filter((report) => report.reportId === id)?.[0];
  return {
    cluster,
    routeReports,
    exceededMaxRoutes,
    requeueReport,
    invalidateFile,
    queueRoute,
    queueRoutes,
    findReport,
    monitor,
    hasStarted,
    reports
  };
}

async function generateClient(options = {}, unlighthouse) {
  const logger = useLogger();
  if (!unlighthouse)
    unlighthouse = useUnlighthouse();
  const { runtimeSettings, resolvedConfig, worker } = unlighthouse;
  const prefix = withTrailingSlash(withLeadingSlash(resolvedConfig.routerPrefix));
  const clientPathFolder = dirname(runtimeSettings.resolvedClientPath);
  await fs.copy(clientPathFolder, runtimeSettings.generatedClientPath);
  const inlineScript = `window.__unlighthouse_static = ${options.static}`;
  let indexHTML = await fs.readFile(runtimeSettings.resolvedClientPath, "utf-8");
  indexHTML = indexHTML.replace(/<script data-unlighthouse-inline>.*?<\/script>/gms, `<script data-unlighthouse-inline>${inlineScript}<\/script>`).replace(/(href|src)="\/assets\/(.*?)"/gm, `$1="${prefix}assets/$2"`);
  await fs.writeFile(resolve(runtimeSettings.generatedClientPath, "index.html"), indexHTML, "utf-8");
  const staticData = {
    reports: [],
    scanMeta: createScanMeta(),
    // need to be selective about what options we put here to avoid exposing anything sensitive
    options: pick$1({
      ...runtimeSettings,
      ...resolvedConfig
    }, [
      "client",
      "site",
      "websocketUrl",
      "lighthouseOptions",
      "scanner",
      "routerPrefix",
      "websocketUrl",
      "apiUrl"
    ])
  };
  staticData.options.lighthouseOptions = { onlyCategories: resolvedConfig.lighthouseOptions.onlyCategories };
  if (options.static) {
    staticData.reports = worker.reports().map((r) => {
      return {
        ...r,
        // avoid exposing user paths
        artifactPath: ""
      };
    });
  }
  await fs.writeFile(
    join(runtimeSettings.generatedClientPath, "assets", "payload.js"),
    `window.__unlighthouse_payload = ${JSON.stringify(staticData)}`,
    { encoding: "utf-8" }
  );
  const globby = await import('globby');
  const clientAssetsPath = join(dirname(runtimeSettings.resolvedClientPath), "assets");
  const indexFile = (await globby.globby(["index.*.js"], { cwd: clientAssetsPath }))?.[0];
  if (indexFile) {
    const indexPath = join(clientAssetsPath, indexFile);
    let indexJS = await fs.readFile(indexPath, "utf-8");
    indexJS = indexJS.replace('const base = "/";', `const base = "${prefix}";`).replace('createWebHistory("/")', `createWebHistory("${prefix}")`);
    await fs.writeFile(indexPath.replace(clientPathFolder, runtimeSettings.generatedClientPath), indexJS, "utf-8");
  } else {
    logger.warn(`Failed to find index.[hash].js file from wd ${clientAssetsPath}.`);
  }
}

function validSitemapEntry(url) {
  return url && (url.startsWith("http") || url.startsWith("/"));
}
async function extractSitemapRoutes(site, sitemaps) {
  site = new $URL(site).origin;
  const unlighthouse = useUnlighthouse();
  const logger = useLogger();
  if (sitemaps === true || sitemaps.length === 0)
    sitemaps = [`${site}/sitemap.xml`];
  const sitemap = new Sitemapper({
    timeout: 15e3,
    // 15 seconds
    debug: unlighthouse.resolvedConfig.debug
  });
  let paths = [];
  for (let sitemapUrl of new Set(sitemaps)) {
    logger.debug(`Attempting to fetch sitemap at ${sitemapUrl}`);
    if (!sitemapUrl.startsWith("http"))
      sitemapUrl = withBase(sitemapUrl, site);
    if (sitemapUrl.endsWith(".txt")) {
      const sitemapTxt = await fetchUrlRaw(
        sitemapUrl,
        unlighthouse.resolvedConfig
      );
      if (sitemapTxt.valid) {
        const sites = sitemapTxt.response.data.trim().split("\n").filter(validSitemapEntry);
        if (sites?.length)
          paths = [...paths, ...sites];
        logger.debug(`Fetched ${sitemapUrl} with ${sites.length} URLs.`);
      }
    } else {
      const { sites } = await sitemap.fetch(sitemapUrl);
      if (sites?.length)
        paths = [...paths, ...sites];
      logger.debug(`Fetched ${sitemapUrl} with ${sites?.length || "0"} URLs.`);
    }
  }
  const filtered = paths.filter(isScanOrigin);
  return { paths: filtered, ignored: paths.length - filtered.length, sitemaps };
}

async function fetchRobotsTxt(site) {
  site = new $URL(site).origin;
  const unlighthouse = useUnlighthouse();
  const logger = useLogger();
  logger.debug(`Scanning ${site}/robots.txt`);
  const robotsTxt = await fetchUrlRaw(
    `${site}/robots.txt`,
    unlighthouse.resolvedConfig
  );
  if (!robotsTxt.valid || !robotsTxt.response) {
    logger.warn("You seem to be missing a robots.txt.");
    return false;
  }
  logger.debug("Found robots.txt");
  return robotsTxt.response.data;
}
function parseRobotsTxt(robotsTxt) {
  const lines = robotsTxt.split("\n");
  const sitemaps = lines.filter((line) => line.toLowerCase().startsWith("sitemap")).map((line) => line.split(/:(.+)/)[1].trim());
  const disallows = lines.filter((line) => line.toLowerCase().startsWith("disallow")).map((line) => {
    const sections = line.trim().split(/:(.+)/);
    if (sections.length >= 2) {
      const [, path] = sections;
      return path.trim();
    }
    return false;
  }).filter(Boolean);
  return {
    sitemaps,
    disallows
  };
}
function mergeRobotsTxtConfig(config, { disallows, sitemaps }) {
  if (disallows.length) {
    disallows = disallows.filter((path) => path !== "/");
    disallows = disallows.map((path) => {
      if (path.includes("*"))
        path = path.replace(/\*/g, ".*");
      else
        path = `${path}.*`;
      return path;
    });
    config.scanner.exclude = [.../* @__PURE__ */ new Set([...config.scanner.exclude || [], ...disallows])];
  }
  if (config.scanner.sitemap !== false && sitemaps.length)
    config.scanner.sitemap = [.../* @__PURE__ */ new Set([...Array.isArray(config.scanner.sitemap) ? config.scanner.sitemap : [], ...sitemaps])];
}

let warnedAboutSampling = false;
const resolveReportableRoutes = async () => {
  const logger = useLogger();
  const { resolvedConfig, hooks, worker, routeDefinitions } = useUnlighthouse();
  const urls = /* @__PURE__ */ new Set([resolvedConfig.site]);
  if (resolvedConfig.urls) {
    let urlsToAdd;
    if (typeof resolvedConfig.urls === "function")
      urlsToAdd = [...await resolvedConfig.urls()];
    else
      urlsToAdd = [...resolvedConfig.urls];
    urlsToAdd.forEach((url) => urls.add(url));
    if (urlsToAdd.length) {
      resolvedConfig.scanner.sitemap = false;
      resolvedConfig.scanner.crawler = false;
      resolvedConfig.scanner.dynamicSampling = false;
      logger.info(`The \`url\` config has been provided with ${urlsToAdd.length} paths for scanning. Disabling sitemap, sampling and crawler.`);
    }
  }
  if (resolvedConfig.scanner.robotsTxt) {
    const robotsTxt = await fetchRobotsTxt(resolvedConfig.site);
    if (robotsTxt) {
      const robotsTxtParsed = parseRobotsTxt(robotsTxt);
      logger.info(`Found /robots.txt, using entries. Sitemaps: ${robotsTxtParsed.sitemaps.length}, Disallow: ${robotsTxtParsed.disallows.length}.`);
      mergeRobotsTxtConfig(resolvedConfig, robotsTxtParsed);
    }
  }
  if (resolvedConfig.scanner.sitemap !== false) {
    const { paths: sitemapUrls, ignored, sitemaps } = await extractSitemapRoutes(resolvedConfig.site, resolvedConfig.scanner.sitemap);
    if (ignored > 0 && !sitemapUrls.length) {
      logger.warn(`Sitemap${sitemaps.length > 1 ? "s" : ""} exists but is being ignored due to a different origin being present`);
    } else if (sitemapUrls.length) {
      logger.info(`Discovered ${sitemapUrls.length} routes from ${sitemaps.length} sitemap${sitemaps.length > 1 ? "s" : ""}.`);
      if (ignored > 0)
        logger.warn(`Ignoring ${ignored} paths from sitemap as their origin differs from the site url.`);
      sitemapUrls.forEach((url) => urls.add(url));
      if (!resolvedConfig.site.includes("localhost") && sitemapUrls.length >= 50) {
        resolvedConfig.scanner.crawler = false;
        logger.info("Disabling crawler mode as sitemap has been provided.");
      }
    } else if (resolvedConfig.scanner.crawler) {
      resolvedConfig.scanner.sitemap = false;
      logger.info("Sitemap appears to be missing, falling back to crawler mode.");
    } else {
      resolvedConfig.scanner.sitemap = false;
      logger.error("Failed to find sitemap.xml and `routes.crawler` has been disabled. Please enable the crawler to continue scan.");
    }
  }
  if (urls.size <= 1 && routeDefinitions?.length) {
    routeDefinitions.filter((r) => !r.path.includes(":")).map((r) => r.path).forEach((url) => urls.add(url));
  }
  if (resolvedConfig.scanner.crawler) {
    hooks.hook("discovered-internal-links", (path, internalLinks) => {
      if (path === "/" && internalLinks.length <= 0 && resolvedConfig.scanner.skipJavascript) {
        resolvedConfig.scanner.skipJavascript = false;
        resolvedConfig.cache = false;
        worker.routeReports.clear();
        worker.queueRoute(normaliseRoute(path));
        logger.warn("No internal links discovered on home page. Switching crawler to execute javascript and disabling cache.");
        return;
      }
      worker.queueRoutes(internalLinks.map((url) => normaliseRoute(url)).map((route) => {
        route.discoveredFrom = path;
        return route;
      }));
    });
  }
  const validUrls = [...urls.values()].filter((url) => isScanOrigin(url));
  if (!resolvedConfig.scanner.dynamicSampling)
    return validUrls.map((url) => normaliseRoute(url));
  const pathsChunkedToGroup = groupBy$1(
    validUrls.map((url) => normaliseRoute(url)),
    resolvedConfig.client.groupRoutesKey.replace("route.", "")
  );
  const pathsSampleChunkedToGroup = map(
    pathsChunkedToGroup,
    // we're matching dynamic rates here, only taking a sample to avoid duplicate tests
    (group) => {
      const { dynamicSampling } = resolvedConfig.scanner;
      if (!dynamicSampling)
        return group;
      if (!warnedAboutSampling && group.length > dynamicSampling) {
        logger.warn("Dynamic sampling is in effect, some of your routes will not be scanned. To disable this behavior, set `scanner.dynamicSampling` to `false`.");
        warnedAboutSampling = true;
      }
      return sampleSize(group, dynamicSampling);
    }
  );
  return pathsSampleChunkedToGroup.flat();
};

const DYNAMIC_ROUTE_REGEX = /^\/([:*])/;
function getRoutePathExtension(key) {
  if (key === "_")
    return "*";
  if (key.startsWith("_"))
    return `:${key.substr(1)}`;
  return key;
}
const sortRoutes = function sortRoutes2(routes) {
  routes.sort((a, b) => {
    if (!a.path.length)
      return -1;
    if (!b.path.length)
      return 1;
    if (a.path === "/")
      return DYNAMIC_ROUTE_REGEX.test(b.path) ? -1 : 1;
    if (b.path === "/")
      return DYNAMIC_ROUTE_REGEX.test(a.path) ? 1 : -1;
    let i;
    let res = 0;
    let y = 0;
    let z = 0;
    const _a = a.path.split("/");
    const _b = b.path.split("/");
    for (i = 0; i < _a.length; i++) {
      if (res !== 0)
        break;
      y = _a[i] === "*" ? 2 : _a[i].includes(":") ? 1 : 0;
      z = _b[i] === "*" ? 2 : _b[i].includes(":") ? 1 : 0;
      res = y - z;
      if (i === _b.length - 1 && res === 0) {
        res = _a[i] === "*" ? -1 : _a.length === _b.length ? a.path.localeCompare(b.path) : _a.length - _b.length;
      }
    }
    if (res === 0) {
      res = _a[i - 1] === "*" && _b[i] ? 1 : _a.length === _b.length ? a.path.localeCompare(b.path) : _a.length - _b.length;
    }
    return res;
  });
  routes.forEach((route) => {
    if (route.children)
      sortRoutes2(route.children);
  });
  return routes;
};
function createRoutes(options) {
  const {
    files,
    srcDir,
    pagesDir = "",
    routeNameSplitter = "-",
    supportedExtensions = ["vue", "js"],
    trailingSlash
  } = options;
  const routes = [];
  files.forEach((file) => {
    const keys = file.replace(new RegExp(`^${pagesDir}`), "").replace(new RegExp(`\\.(${supportedExtensions.join("|")})$`), "").replace(/\/{2,}/g, "/").split("/").slice(1);
    const route = { name: "", path: "", component: resolve$1(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      const sanitizedKey = key.startsWith("_") ? key.substr(1) : key;
      route.name = route.name ? route.name + routeNameSplitter + sanitizedKey : sanitizedKey;
      route.name += key === "_" ? "all" : "";
      route.chunkName = file.replace(new RegExp(`\\.(${supportedExtensions.join("|")})$`), "");
      const child = parent.find((parentRoute) => parentRoute.name === route.name);
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = "";
      } else if (key === "index" && i + 1 === keys.length) {
        route.path += i > 0 ? "" : "/";
      } else {
        route.path += `/${normalizeURL(getRoutePathExtension(key))}`;
        if (key.startsWith("_") && key.length > 1)
          route.path += "?";
      }
    });
    if (trailingSlash !== void 0) {
      route.pathToRegexpOptions = { ...route.pathToRegexpOptions, strict: true };
      if (trailingSlash && !route.path.endsWith("*"))
        route.path = withTrailingSlash(route.path);
      else
        route.path = withoutTrailingSlash(route.path);
    }
    parent.push(route);
  });
  sortRoutes(routes);
  return cleanChildrenRoutes(routes, false, routeNameSplitter, trailingSlash);
}
function cleanChildrenRoutes(routes, isChild = false, routeNameSplitter = "-", trailingSlash, parentRouteName = "") {
  const regExpIndex = new RegExp(`${routeNameSplitter}index$`);
  const regExpParentRouteName = new RegExp(`^${parentRouteName}${routeNameSplitter}`);
  const routesIndex = [];
  routes.forEach((route) => {
    if (regExpIndex.test(route.name) || route.name === "index") {
      const res = route.name.replace(regExpParentRouteName, "").split(routeNameSplitter);
      routesIndex.push(res);
    }
  });
  routes.forEach((route) => {
    route.path = isChild ? route.path.replace("/", "") : route.path;
    if (route.path.includes("?")) {
      if (route.name.endsWith(`${routeNameSplitter}index`))
        route.path = route.path.replace(/\?\/?$/, trailingSlash ? "/" : "");
      const names = route.name.replace(regExpParentRouteName, "").split(routeNameSplitter);
      const paths = route.path.split("/");
      if (!isChild)
        paths.shift();
      routesIndex.forEach((r) => {
        const i = r.indexOf("index");
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i)
              paths[a] = paths[a].replace("?", "");
            if (a < i && names[a] !== r[a])
              break;
          }
        }
      });
      route.path = (isChild ? "" : "/") + paths.join("/");
    }
    route.name = route.name.replace(regExpIndex, "");
    if (route.children) {
      const defaultChildRoute = route.children.find((child) => child.path === "/" || child.path === "");
      const routeName = route.name;
      if (defaultChildRoute) {
        route.children.forEach((child) => {
          if (child.path !== defaultChildRoute.path) {
            const parts = child.path.split("/");
            parts[1] = parts[1].endsWith("?") ? parts[1].substr(0, parts[1].length - 1) : parts[1];
            child.path = parts.join("/");
          }
        });
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true, routeNameSplitter, trailingSlash, routeName);
    }
  });
  return routes;
}

async function discoverRouteDefinitions() {
  const { resolvedConfig } = useUnlighthouse();
  if (!resolvedConfig.discovery)
    return [];
  const logger = useLogger();
  const { supportedExtensions, pagesDir } = resolvedConfig.discovery;
  const dir = pagesDir === "" ? resolvedConfig.root.replace(`${resolvedConfig.root}/`, "") : pagesDir;
  const resolveFiles = async (dir2) => {
    const { globby } = await import('globby');
    const extensions = supportedExtensions.length > 1 ? `{${supportedExtensions.join(",")}}` : supportedExtensions[0];
    return await globby([
      join(dir2, "**", `*.${extensions}`),
      "!**/README.md",
      "!**/node_modules"
    ], {
      cwd: resolvedConfig.root,
      // avoid some edge-cases
      deep: 5,
      // avoid scanning node_modules and any other expensive dirs
      gitignore: true
    });
  };
  const files = {};
  const ext = new RegExp(`\\.(${supportedExtensions.join("|")})$`);
  const resolvedPages = await resolveFiles(dir);
  for (const page of resolvedPages) {
    const key = page.replace(ext, "");
    if (/\.vue$/.test(page) || !files[key])
      files[key] = page.replace(/(['"])/g, "\\$1");
  }
  logger.debug(`Discovered \`${resolvedPages.length}\` page files from  \`${join(resolvedConfig.root, dir)}\`. Mapping to route definitions.`);
  if (resolvedPages.length)
    logger.debug(resolvedPages);
  return createRoutes({
    files: Object.values(files),
    srcDir: resolvedConfig.root,
    pagesDir: dir,
    routeNameSplitter: "-",
    supportedExtensions,
    trailingSlash: false
  }).map((route) => {
    const pathNodes = route.path.split("/");
    route.path = pathNodes.map((n) => {
      if (n.startsWith("[") && n.endsWith("]")) {
        const strippedNode = n.replace("[", "").replace("]", "").replace("...", "");
        return `:${strippedNode}`;
      }
      return n;
    }).join("/");
    return route;
  });
}

const resolveUserConfig = async (userConfig) => {
  const logger = useLogger();
  const merger = createDefu((obj, key, value) => {
    if ((key === "supportedExtensions" || key === "onlyCategories") && value) {
      obj[key] = value;
      return true;
    }
  });
  const config = merger(userConfig, defaultConfig);
  if (config.site) {
    config.site = normaliseHost(config.site);
  }
  if (config.lighthouseOptions) {
    if (config.lighthouseOptions.onlyCategories?.length) {
      config.lighthouseOptions.onlyCategories = defaultConfig.lighthouseOptions.onlyCategories.filter((column) => config.lighthouseOptions.onlyCategories.includes(column));
    }
  } else {
    config.lighthouseOptions = {};
  }
  if (!config.site || config.site.includes("localhost") || !config.scanner?.throttle) {
    config.lighthouseOptions.throttlingMethod = "provided";
    config.lighthouseOptions.throttling = {
      rttMs: 0,
      throughputKbps: 0,
      cpuSlowdownMultiplier: 1,
      requestLatencyMs: 0,
      // 0 means unset
      downloadThroughputKbps: 0,
      uploadThroughputKbps: 0
    };
  }
  config.scanner.exclude = config.scanner?.exclude || [];
  config.scanner.exclude.push("/cdn-cgi/*");
  config.chrome = defu(config.chrome || {}, {
    useSystem: true,
    useDownloadFallback: true,
    downloadFallbackVersion: 1095492,
    downloadFallbackCacheDir: join(homedir(), ".unlighthouse")
  });
  if (config.auth) {
    config.lighthouseOptions.extraHeaders = config.lighthouseOptions.extraHeaders || {};
    if (!config.lighthouseOptions.extraHeaders.Authorization) {
      const credentials = `${config.auth.username}:${config.auth.password}`;
      config.lighthouseOptions.extraHeaders.Authorization = `Basic ${Buffer$1.from(credentials).toString("base64")}`;
    }
  }
  if (config.client?.columns) {
    config.client.columns = pick$1(config.client.columns, ["overview", ...config.lighthouseOptions.onlyCategories]);
  }
  if (config.root && config.discovery && config.discovery.pagesDir === "pages") {
    const pagesDirExist = await pathExists(join(config.root, config.discovery.pagesDir));
    if (!pagesDirExist) {
      logger.debug("Unable to locale page files, disabling route discovery.");
      config.discovery = false;
    }
  }
  config.lighthouseOptions.formFactor = config.lighthouseOptions.formFactor || config.scanner?.device || "mobile";
  if (config.lighthouseOptions.formFactor === "desktop") {
    config.lighthouseOptions.screenEmulation = {
      mobile: false,
      width: 1350,
      height: 940,
      deviceScaleFactor: 1,
      disabled: false
    };
  } else {
    config.lighthouseOptions.screenEmulation = {
      mobile: true,
      width: 412,
      height: 823,
      deviceScaleFactor: 1.75,
      disabled: false
    };
  }
  if (!config.lighthouseOptions.emulatedUserAgent) {
    if (config.lighthouseOptions.formFactor === "mobile")
      config.lighthouseOptions.emulatedUserAgent = "Mozilla/5.0 (Linux; Android 11; moto g power (2022)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Mobile Safari/537.36";
    else
      config.lighthouseOptions.emulatedUserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36";
  }
  if (userConfig.extraHeaders)
    config.lighthouseOptions.extraHeaders = userConfig.extraHeaders;
  if (config.routerPrefix)
    config.routerPrefix = withSlashes(config.routerPrefix);
  config.puppeteerOptions = config.puppeteerOptions || {};
  config.puppeteerClusterOptions = config.puppeteerClusterOptions || {};
  config.puppeteerOptions = defu(config.puppeteerOptions, {
    // set viewport
    headless: true,
    ignoreHTTPSErrors: true
  });
  config.puppeteerOptions.defaultViewport = config.lighthouseOptions.screenEmulation;
  let foundChrome = !!config.puppeteerOptions?.executablePath;
  if (config.chrome.useSystem && !foundChrome) {
    const chromePath = Launcher.getFirstInstallation();
    if (chromePath) {
      logger.info(`Using system chrome located at: \`${chromePath}\`.`);
      config.puppeteerClusterOptions.puppeteer = puppeteer;
      config.puppeteerOptions.executablePath = chromePath;
      foundChrome = true;
    }
  }
  if (!foundChrome) {
    try {
      await resolve$2("puppeteer");
      foundChrome = true;
      logger.info("Using puppeteer dependency for chrome.");
    } catch (e) {
      logger.debug("Puppeteer does not exist as a dependency.", e);
    }
  }
  if (config.chrome.useDownloadFallback && !foundChrome) {
    const browserOptions = {
      cacheDir: join(homedir(), ".unlighthouse"),
      buildId: "1095492",
      browser: "chromium"
    };
    const chromePath = computeExecutablePath(browserOptions);
    if (!existsSync(chromePath)) {
      logger.warn("Failed to find chromium, attempting to download it instead.");
      let lastPercent = 0;
      await install({
        ...browserOptions,
        downloadProgressCallback: (downloadedBytes, toDownloadBytes) => {
          const percent = Math.round(downloadedBytes / toDownloadBytes * 100);
          if (percent % 5 === 0 && lastPercent !== percent) {
            logger.info(`Downloading chromium: ${percent}%`);
            lastPercent = percent;
          }
        }
      });
    }
    logger.info(`Using temporary downloaded chromium v1095492 located at: ${chromePath}`);
    config.puppeteerOptions.executablePath = chromePath;
    foundChrome = true;
  }
  if (!foundChrome)
    throw new Error("Failed to find chrome. Please ensure you have a valid chrome installed.");
  return config;
};

const maxCharsPerLine = () => (process.stdout.columns || 100) * 80 / 100;
function indent(count, chr = " ") {
  return chr.repeat(count);
}
function indentLines(string, spaces, firstLineSpaces) {
  const lines = Array.isArray(string) ? string : string.split("\n");
  let s = "";
  if (lines.length) {
    const i0 = indent(firstLineSpaces === void 0 ? spaces : firstLineSpaces);
    s = i0 + lines.shift();
  }
  if (lines.length) {
    const i = indent(spaces);
    s += `
${lines.map((l) => i + l).join("\n")}`;
  }
  return s;
}
function foldLines(string, spaces, firstLineSpaces, charsPerLine = maxCharsPerLine()) {
  return indentLines(wrapAnsi(string, charsPerLine), spaces, firstLineSpaces);
}
function box(message, title, options) {
  return `${boxen([
    title || chalk.white("Nuxt Message"),
    "",
    chalk.white(foldLines(message, 0, 0, maxCharsPerLine()))
  ].join("\n"), Object.assign({
    borderColor: "white",
    borderStyle: "round",
    padding: 1,
    margin: 1
  }, options))}
`;
}
function successBox(message, title) {
  return box(message, title || chalk.green("\u2714 Nuxt Success"), {
    borderColor: "green"
  });
}

const engineContext = createContext();
const useUnlighthouse = engineContext.tryUse;
function defineConfig(config) {
  return config;
}
async function createUnlighthouse(userConfig, provider) {
  const logger = createLogger(userConfig.debug);
  const { __dirname } = createCommonJS(import.meta.url);
  if (userConfig.root && !isAbsolute(userConfig.root))
    userConfig.root = join(process.cwd(), userConfig.root);
  else if (!userConfig.root)
    userConfig.root = process.cwd();
  logger.debug(`Starting Unlighthouse at root: \`${userConfig.root}\` cwd: ${process.cwd()}`);
  let configFile = null;
  const configDefinition = await loadConfig({
    cwd: userConfig.root,
    sources: [
      {
        files: [
          "unlighthouse.config",
          // may provide the config file as an argument
          ...userConfig.configFile ? [userConfig.configFile] : []
        ],
        // default extensions
        extensions: ["ts", "js", "mjs", "cjs", "json", ""]
      }
    ]
  });
  logger.debug("Discovered config definition", configDefinition);
  if (configDefinition.sources?.[0]) {
    configFile = configDefinition.sources[0];
    const config = configDefinition.config?.default || configDefinition.config;
    userConfig = defu(config, userConfig);
  }
  const runtimeSettings = {
    configFile: configFile || void 0,
    moduleWorkingDir: __dirname,
    configCacheKey: "",
    lighthouseProcessPath: ""
  };
  runtimeSettings.lighthouseProcessPath = await resolvePath(
    join(runtimeSettings.moduleWorkingDir, "process", "lighthouse.mjs")
  ).catch(() => {
  });
  if (!await fs.pathExists(runtimeSettings.lighthouseProcessPath)) {
    runtimeSettings.lighthouseProcessPath = await resolvePath(
      join(runtimeSettings.moduleWorkingDir, "process", "lighthouse.ts")
    );
  }
  runtimeSettings.configCacheKey = objectHash({ ...userConfig, version }).substring(0, 4);
  const resolvedConfig = await resolveUserConfig(userConfig);
  logger.debug("Post config resolution", resolvedConfig);
  const hooks = createHooks();
  if (resolvedConfig.hooks)
    hooks.addHooks(resolvedConfig.hooks);
  await hooks.callHook("resolved-config", resolvedConfig);
  logger.debug(`Creating Unlighthouse ${configFile ? `using config from \`${configFile}\`` : ""}`);
  const ws = provider?.name === "ci" ? null : new WS();
  const ctx = {
    runtimeSettings,
    hooks,
    resolvedConfig,
    ws,
    provider
  };
  engineContext.set(ctx, true);
  const tasks = {
    inspectHtmlTask,
    runLighthouseTask
  };
  const worker = await createUnlighthouseWorker(tasks);
  ctx.worker = worker;
  ctx.setCiContext = async () => {
    const $site = new $URL(resolvedConfig.site);
    logger.debug(`Setting Unlighthouse CI Context [Site: ${$site}]`);
    let outputPath = join(
      resolvedConfig.root,
      resolvedConfig.outputPath,
      // fix windows not supporting : in paths
      $site.hostname.replace(":", "\uA789"),
      runtimeSettings.configCacheKey || ""
    );
    try {
      await fs.mkdir(join(resolvedConfig.root, resolvedConfig.outputPath), { recursive: true });
    } catch (e) {
      logger.error(`Failed to create output directory. Please check unlighthouse has permissions to: ${resolvedConfig.outputPath}`, e);
    }
    try {
      await fs.mkdir(outputPath, { recursive: true });
    } catch (e) {
      logger.error(`Failed to create output directory. Please check unlighthouse has permission to create files and folders in: ${resolvedConfig.outputPath}`, e);
    }
    if (provider?.name === "ci")
      outputPath = join(resolvedConfig.root, resolvedConfig.outputPath);
    ctx.runtimeSettings = {
      ...ctx.runtimeSettings,
      outputPath,
      generatedClientPath: outputPath,
      resolvedClientPath: await resolvePath(ClientPkg, { url: import.meta.url })
    };
    if (!resolvedConfig.cache && existsSync(resolvedConfig.outputPath)) {
      logger.debug(`\`cache\` is disabled, deleting cache folder: \`${resolvedConfig.outputPath}\``);
      fs.rmSync(resolvedConfig.outputPath, { recursive: true });
    }
    fs.ensureDirSync(ctx.runtimeSettings.outputPath);
    return ctx;
  };
  ctx.setSiteUrl = async (url) => {
    const site = normaliseHost(url);
    ctx.runtimeSettings.siteUrl = new $URL(site);
    logger.debug(`Setting Unlighthouse Site URL [Site: ${site}]`);
    const outputPath = join(
      resolvedConfig.root,
      resolvedConfig.outputPath,
      // fix windows not supporting : in paths
      runtimeSettings.siteUrl?.hostname.replace(":", "\uA789") || "",
      runtimeSettings.configCacheKey || ""
    );
    ctx.resolvedConfig.site = site;
    ctx.runtimeSettings.outputPath = outputPath;
    ctx.runtimeSettings.generatedClientPath = outputPath;
    await hooks.callHook("site-changed", site);
  };
  ctx.setServerContext = async ({ url, server, app }) => {
    const $server = new $URL(url);
    logger.debug(`Setting Unlighthouse Server Context [Server: ${$server}]`);
    const clientUrl = joinURL($server.toString(), resolvedConfig.routerPrefix);
    const apiPath = joinURL(resolvedConfig.routerPrefix, resolvedConfig.apiPrefix);
    ctx.runtimeSettings.serverUrl = url;
    ctx.runtimeSettings = {
      ...ctx.runtimeSettings,
      apiPath,
      server,
      resolvedClientPath: await resolvePath(ClientPkg, { url: import.meta.url }),
      clientUrl,
      apiUrl: joinURL($server.toString(), apiPath),
      websocketUrl: `ws://${joinURL($server.host, apiPath, "/ws")}`
    };
    ctx.api = await createApi(app);
    if (ws) {
      server.on("upgrade", (request, socket) => {
        ws.handleUpgrade(request, socket);
      });
    }
    if (!resolvedConfig.cache && existsSync(resolvedConfig.outputPath)) {
      logger.debug(`\`cache\` is disabled, deleting cache folder: \`${resolvedConfig.outputPath}\``);
      fs.rmSync(resolvedConfig.outputPath, { recursive: true });
    }
    fs.ensureDirSync(ctx.runtimeSettings.outputPath);
    await generateClient();
    if (provider?.name !== "cli") {
      hooks.hookOnce("visited-client", () => {
        ctx.start();
      });
    }
    return ctx;
  };
  ctx.start = async () => {
    if (worker.hasStarted()) {
      logger.debug("Attempted to start Unlighthouse, has already started.");
      return ctx;
    }
    logger.debug(`Starting Unlighthouse [Server: ${provider?.name === "ci" ? "N/A" : ctx.runtimeSettings.clientUrl} Site: ${ctx.resolvedConfig.site} Debug: \`${ctx.resolvedConfig.debug}\`]`);
    if (typeof provider?.routeDefinitions === "function")
      ctx.routeDefinitions = await provider.routeDefinitions();
    else
      ctx.routeDefinitions = provider?.routeDefinitions;
    if (!ctx.routeDefinitions && resolvedConfig.discovery !== false) {
      logger.debug("No route definitions provided, discovering them ourselves.");
      ctx.routeDefinitions = await discoverRouteDefinitions();
    }
    if (ctx.routeDefinitions?.length) {
      if (typeof ctx.provider.mockRouter === "function")
        ctx.provider.mockRouter = ctx.provider.mockRouter(ctx.routeDefinitions);
      else if (!ctx.provider.mockRouter)
        ctx.provider.mockRouter = createMockRouter(ctx.routeDefinitions);
      logger.debug(`Discovered ${ctx.routeDefinitions?.length} definitions and setup mock router.`);
    }
    ctx.routes = await resolveReportableRoutes();
    await createBroadcastingEvents();
    worker.queueRoutes(ctx.routes);
    if (provider?.name !== "ci") {
      let chalk = await import('chalk');
      if (chalk.default) {
        chalk = chalk.default;
      }
      const label = (name) => chalk.bold.magenta(`\u25B8 ${name}:`);
      let mode = "";
      if (resolvedConfig.urls?.length)
        mode = "Manual";
      if (resolvedConfig.scanner.sitemap !== false)
        mode += "Sitemap";
      if (resolvedConfig.scanner.crawler)
        mode += mode.length > 0 ? " + Crawler" : "Crawler";
      let latestTag = `v${version}`;
      try {
        latestTag = (await $fetch("https://ungh.unjs.io/repos/harlan-zw/unlighthouse/releases/latest")).release.tag;
      } catch (e) {
      }
      const title = [
        `\u26F5  ${chalk.bold.blueBright(AppName)} ${chalk.dim(`${provider?.name} @ v${version}`)}`
      ];
      if (latestTag !== `v${version}`) {
        title.push(...[
          "",
          `\u{1F389} New version ${latestTag} available! Use the latest:`,
          chalk.gray(` > ${chalk.underline(`npx unlighthouse@${latestTag} --site ${resolvedConfig.site}`)}`)
        ]);
      }
      title.push(...[
        "",
        `${label("Scanning")} ${resolvedConfig.site}`,
        `${label("Route Discovery")} ${mode} ${ctx.routes.length > 1 ? chalk.dim(`${ctx.routes.length} initial URLs`) : ""}`,
        "",
        chalk.dim(" \u{1F496} Like Unlighthouse? Support the development: https://github.com/sponsors/harlan-zw")
      ]);
      if (ctx.routeDefinitions?.length)
        title.push(`${label("Route Definitions")} ${ctx.routeDefinitions.length}`);
      process.stdout.write(successBox(
        // messages
        [
          ctx.runtimeSettings.clientUrl ? chalk.whiteBright(`Report: ${ctx.runtimeSettings.clientUrl}`) : ""
        ].join("\n"),
        // title
        title.join("\n")
      ));
      if (existsSync(join(ctx.runtimeSettings.generatedClientPath, "reports", "lighthouse.json")) && ctx.resolvedConfig.cache)
        logger.info(`Restoring reports from cache. ${chalk.gray("You can disable this behavior by passing --no-cache.")}`);
    }
    return ctx;
  };
  if (ctx.resolvedConfig.site)
    ctx.setSiteUrl(resolvedConfig.site);
  return ctx;
}

const ReportArtifacts = {
  html: "payload.html",
  reportHtml: "lighthouse.html",
  screenshot: "screenshot.jpeg",
  fullScreenScreenshot: "full-screenshot.jpeg",
  screenshotThumbnailsDir: "__screenshot-thumbnails__",
  reportJson: "lighthouse.json"
};
const trimSlashes = (s) => withoutLeadingSlash(withoutTrailingSlash(s));
const withSlashes = (s) => withLeadingSlash(withTrailingSlash(s)) || "/";
function sanitiseUrlForFilePath(url) {
  url = trimSlashes(url);
  if (url.endsWith(".html"))
    url = url.replace(/\.html$/, "");
  return url.split("/").map((part) => sanitize(slugify(part))).join("/");
}
function hashPathName(path) {
  return createHash("md5").update(sanitiseUrlForFilePath(path)).digest("hex").substring(0, 6);
}
function normaliseHost(host) {
  if (!host.startsWith("http"))
    host = `http${host.startsWith("localhost") ? "" : "s"}://${host}`;
  return host.includes(".") ? host : withTrailingSlash(host);
}
function createTaskReportFromRoute(route) {
  const { runtimeSettings, resolvedConfig } = useUnlighthouse();
  const reportId = hashPathName(route.path);
  const reportPath = join(runtimeSettings.generatedClientPath, "reports", sanitiseUrlForFilePath(route.path));
  ensureDirSync(reportPath);
  return {
    tasks: {
      runLighthouseTask: "waiting",
      inspectHtmlTask: "waiting"
    },
    route,
    reportId,
    artifactPath: reportPath,
    artifactUrl: joinURL(resolvedConfig.routerPrefix, "reports", sanitiseUrlForFilePath(route.path))
  };
}
function base64ToBuffer(dataURI) {
  return Buffer$1.from(dataURI.split(",")[1], "base64");
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / k ** i).toFixed(dm))} ${sizes[i]}`;
}
async function fetchUrlRaw(url, resolvedConfig) {
  const axiosOptions = {};
  if (resolvedConfig.auth)
    axiosOptions.auth = resolvedConfig.auth;
  axiosOptions.headers = axiosOptions.headers || {};
  if (resolvedConfig.cookies) {
    axiosOptions.headers.Cookie = resolvedConfig.cookies.map((cookie) => `${cookie.name}=${cookie.value}`).join("; ");
  }
  if (resolvedConfig.extraHeaders)
    axiosOptions.headers = { ...resolvedConfig.extraHeaders, ...axiosOptions.headers };
  axiosOptions.httpsAgent = new https.Agent({
    rejectUnauthorized: false
  });
  axiosOptions.withCredentials = true;
  try {
    const response = await axios.get(url, axiosOptions);
    let responseUrl = response.request.res.responseUrl;
    if (responseUrl && axiosOptions.auth) {
      responseUrl = responseUrl.replace(/(?<=https?:\/\/)(.+?@)/g, "");
    }
    const redirected = responseUrl && responseUrl !== url;
    const redirectUrl = responseUrl;
    if (response.status < 200 || response.status >= 300 && !redirected) {
      return {
        valid: false,
        redirected,
        response,
        redirectUrl
      };
    }
    return {
      valid: true,
      redirected,
      response,
      redirectUrl
    };
  } catch (e) {
    return {
      error: e,
      valid: false
    };
  }
}
function asRegExp(rule) {
  if (rule instanceof RegExp)
    return rule;
  rule = rule.replace(/[-{}()+?.,\\^|#\s]/g, "\\$&");
  return new RegExp(rule);
}

export { ReportArtifacts, createUnlighthouse, defineConfig, fetchUrlRaw, generateClient, normaliseHost, useLogger, useUnlighthouse };
